//判断数据存储的大小端
#include "stdio.h"
int main()
{
	int a = 1;
	if (*(char*)&a == 1)
		printf("小端");
	else printf("大端");
}

//数据存储课堂练习1
#include "stdio.h"
int main()
{
	char a = -1;//a=(char )(int -1)=(char)(111111111...11111111)（补码）=11111111;截断
	signed char b = -1;//b=(char )(int -1)=(char)(111111111...11111111)（补码）=11111111;
	unsigned char c = -1;//c=(char )(int -1)=(char)(111111111...11111111)（补码）=11111111;
	//-1本质上是整形的-1，在赋值的过程中被unsigned char截断（发生在存储的过程中），类型变为unsigned char
	printf("a=%d,b=%d,c=%d\n", a, b, c);
	//打印a的时候会发生整型提升，a=11111111...11111111；源码为a=10000000...00000001=-1
	//打印c的时候会发生整型提升，会按照原数据类型的形式提升至整形，c=000000...0011111111；源码为c=00000000...11111111=255
}

//数据存储课堂练习2
int main()
{
	char a = -128;//100000...0010000000=>（补码）11111111..1101111111+1=1111..1110000000=>（截断）10000000
	printf("%u", a);//1111111...10000000,%u是无符号整数，他会将要打印的数据视为无符号整数，也就是说不需要转化为原码输出，而%d是有符号整数，要找到原码打印
}
//数据存储课堂练习3
int main()
{
	int i = -20;//100000....00010100(原码)->11111...11101011+1(补码)=>1111...11101100（补码）
	unsigned int j = 10;//0000....00001010（补码=原码）
	printf("%d\n", i + j);//1111....11110110（补码）->1000....00001001（反码）->1000...00001000（原码）
}
//数据存储课堂练习4
int main()
{
	unsigned int i;
	for (i = 9; i >= 0; i--)//0-1=-1,但是-1的原码是100000....00000001，补码是11111111...11111111，在无符号数中这个数非常大。
		printf("%u\n", i);
}
